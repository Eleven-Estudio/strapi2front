/**
 * JSDoc service generator
 * Generates .js files with JSDoc annotations for services
 */

import path from 'node:path';
import type { ParsedSchema, CollectionType, SingleType } from '@strapi2front/core';
import type { StrapiVersion } from '../../shared/types.js';
import { writeFile, ensureDir } from '../../utils/file.js';
import { toPascalCase, toCamelCase, toKebabCase } from '../../utils/naming.js';

export interface JSDocServicesOptions {
  outputDir: string;
  typesImportPath: string;
  strapiVersion?: StrapiVersion;
}

/**
 * Generate JSDoc service files from parsed schema
 */
export async function generateJSDocServices(
  schema: ParsedSchema,
  options: JSDocServicesOptions
): Promise<string[]> {
  const { outputDir, typesImportPath, strapiVersion = "v5" } = options;
  const generatedFiles: string[] = [];

  await ensureDir(outputDir);

  // Generate services for collections
  for (const collection of schema.collections) {
    const fileName = `${toKebabCase(collection.singularName)}.service.js`;
    const filePath = path.join(outputDir, fileName);
    const content = generateCollectionService(collection, typesImportPath, strapiVersion);
    await writeFile(filePath, content);
    generatedFiles.push(filePath);
  }

  // Generate services for single types
  for (const single of schema.singles) {
    const fileName = `${toKebabCase(single.singularName)}.service.js`;
    const filePath = path.join(outputDir, fileName);
    const content = generateSingleService(single, typesImportPath, strapiVersion);
    await writeFile(filePath, content);
    generatedFiles.push(filePath);
  }

  return generatedFiles;
}

/**
 * Generate service for a collection type
 */
function generateCollectionService(
  collection: CollectionType,
  typesImportPath: string,
  strapiVersion: StrapiVersion
): string {
  const typeName = toPascalCase(collection.singularName);
  const serviceName = toCamelCase(collection.singularName) + 'Service';
  const fileName = toKebabCase(collection.singularName);
  const endpoint = collection.pluralName;
  const isV4 = strapiVersion === "v4";

  const idParam = isV4 ? 'id' : 'documentId';
  const idType = isV4 ? 'number' : 'string';

  // Feature flags
  const hasSlug = 'slug' in collection.attributes;
  const { localized, draftAndPublish } = collection;

  // Build locale and status options
  const localeOption = localized ? '\n * @property {string} [locale] - Locale code' : '';
  const statusOption = draftAndPublish ? "\n * @property {'draft'|'published'} [status] - Publication status" : '';

  const findBySlugMethod = hasSlug ? `
/**
 * Find one ${collection.singularName} by slug
 * @param {string} slug - The slug to search for
 * @param {FindOneOptions} [options={}] - Query options
 * @returns {Promise<${typeName}|null>}
 */
async findBySlug(slug, options = {}) {
  const { data } = await this.findMany({
    filters: { slug: { $eq: slug } },
    pagination: { pageSize: 1 },
    populate: options.populate,${localized ? '\n    locale: options.locale,' : ''}${draftAndPublish ? '\n    status: options.status,' : ''}
  });

  return data[0] || null;
},
` : '';

  return `/**
 * ${collection.displayName} Service
 * ${collection.description || ''}
 * Generated by strapi2front
 * Strapi version: ${strapiVersion}
 */

import { collection } from '../client.js';

/** @typedef {import('${typesImportPath}/collections/${fileName}').${typeName}} ${typeName} */
/** @typedef {import('${typesImportPath}/collections/${fileName}').${typeName}Filters} ${typeName}Filters */
/** @typedef {import('${typesImportPath}/utils').StrapiPagination} StrapiPagination */
${localized ? `/** @typedef {import('../locales').Locale} Locale */` : ''}

/**
 * @typedef {Object} FindManyOptions
 * @property {${typeName}Filters} [filters] - Filter conditions
 * @property {{page?: number, pageSize?: number, start?: number, limit?: number}} [pagination] - Pagination options
 * @property {string|string[]} [sort] - Sort order
 * @property {string|string[]|Object} [populate] - Relations to populate${localeOption}${statusOption}
 */

/**
 * @typedef {Object} FindOneOptions
 * @property {string|string[]|Object} [populate] - Relations to populate${localeOption}${statusOption}
 */

/** @type {ReturnType<typeof collection<${typeName}>>} */
const ${toCamelCase(collection.singularName)}Collection = collection('${endpoint}');

export const ${serviceName} = {
  /**
   * Find multiple ${collection.pluralName}
   * @param {FindManyOptions} [options={}] - Query options
   * @returns {Promise<{data: ${typeName}[], pagination: StrapiPagination}>}
   */
  async findMany(options = {}) {
    const response = await ${toCamelCase(collection.singularName)}Collection.find({
      filters: options.filters,
      pagination: options.pagination,
      sort: options.sort,
      populate: options.populate,${localized ? '\n      locale: options.locale,' : ''}${draftAndPublish ? '\n      status: options.status,' : ''}
    });

    return {
      data: response.data,
      pagination: response.meta.pagination,
    };
  },

  /**
   * Find all ${collection.pluralName} (handles pagination automatically)
   * @param {Omit<FindManyOptions, 'pagination'>} [options={}] - Query options
   * @returns {Promise<${typeName}[]>}
   */
  async findAll(options = {}) {
    /** @type {${typeName}[]} */
    const allItems = [];
    let page = 1;
    let hasMore = true;

    while (hasMore) {
      const { data, pagination } = await this.findMany({
        ...options,
        pagination: { page, pageSize: 100 },
      });

      allItems.push(...data);
      hasMore = page < pagination.pageCount;
      page++;
    }

    return allItems;
  },

  /**
   * Find one ${collection.singularName} by ${idParam}
   * @param {${idType}} ${idParam} - The ${idParam} to find
   * @param {FindOneOptions} [options={}] - Query options
   * @returns {Promise<${typeName}|null>}
   */
  async findOne(${idParam}, options = {}) {
    try {
      const response = await ${toCamelCase(collection.singularName)}Collection.findOne(${idParam}, {
        populate: options.populate,${localized ? '\n        locale: options.locale,' : ''}${draftAndPublish ? '\n        status: options.status,' : ''}
      });

      return response.data;
    } catch (error) {
      if (error instanceof Error && error.message.includes('404')) {
        return null;
      }
      throw error;
    }
  },
${findBySlugMethod}
  /**
   * Create a new ${collection.singularName}
   * @param {Partial<${typeName}>} data - The data to create
   * @returns {Promise<${typeName}>}
   */
  async create(data) {
    const response = await ${toCamelCase(collection.singularName)}Collection.create({ data });
    return response.data;
  },

  /**
   * Update a ${collection.singularName}
   * @param {${idType}} ${idParam} - The ${idParam} to update
   * @param {Partial<${typeName}>} data - The data to update
   * @returns {Promise<${typeName}>}
   */
  async update(${idParam}, data) {
    const response = await ${toCamelCase(collection.singularName)}Collection.update(${idParam}, { data });
    return response.data;
  },

  /**
   * Delete a ${collection.singularName}
   * @param {${idType}} ${idParam} - The ${idParam} to delete
   * @returns {Promise<void>}
   */
  async delete(${idParam}) {
    await ${toCamelCase(collection.singularName)}Collection.delete(${idParam});
  },

  /**
   * Count ${collection.pluralName}
   * @param {${typeName}Filters} [filters] - Filter conditions
   * @returns {Promise<number>}
   */
  async count(filters) {
    const { pagination } = await this.findMany({
      filters,
      pagination: { pageSize: 1 },
    });

    return pagination.total;
  },
};
`;
}

/**
 * Generate service for a single type
 */
function generateSingleService(
  single: SingleType,
  typesImportPath: string,
  strapiVersion: StrapiVersion
): string {
  const typeName = toPascalCase(single.singularName);
  const serviceName = toCamelCase(single.singularName) + 'Service';
  const fileName = toKebabCase(single.singularName);
  const endpoint = single.singularName;

  // Feature flags
  const { localized, draftAndPublish } = single;

  // Build locale and status options
  const localeOption = localized ? '\n * @property {string} [locale] - Locale code' : '';
  const statusOption = draftAndPublish ? "\n * @property {'draft'|'published'} [status] - Publication status" : '';

  return `/**
 * ${single.displayName} Service (Single Type)
 * ${single.description || ''}
 * Generated by strapi2front
 * Strapi version: ${strapiVersion}
 */

import { single } from '../client.js';

/** @typedef {import('${typesImportPath}/collections/${fileName}').${typeName}} ${typeName} */
${localized ? `/** @typedef {import('../locales').Locale} Locale */` : ''}

/**
 * @typedef {Object} FindOptions
 * @property {string|string[]|Object} [populate] - Relations to populate${localeOption}${statusOption}
 */

/** @type {ReturnType<typeof single<${typeName}>>} */
const ${toCamelCase(single.singularName)}Single = single('${endpoint}');

export const ${serviceName} = {
  /**
   * Get ${single.displayName}
   * @param {FindOptions} [options={}] - Query options
   * @returns {Promise<${typeName}|null>}
   */
  async find(options = {}) {
    try {
      const response = await ${toCamelCase(single.singularName)}Single.find({
        populate: options.populate,${localized ? '\n        locale: options.locale,' : ''}${draftAndPublish ? '\n        status: options.status,' : ''}
      });

      return response.data;
    } catch (error) {
      if (error instanceof Error && error.message.includes('404')) {
        return null;
      }
      throw error;
    }
  },

  /**
   * Update ${single.displayName}
   * @param {Partial<${typeName}>} data - The data to update
   * @returns {Promise<${typeName}>}
   */
  async update(data) {
    const response = await ${toCamelCase(single.singularName)}Single.update({ data });
    return response.data;
  },

  /**
   * Delete ${single.displayName}
   * @returns {Promise<void>}
   */
  async delete() {
    await ${toCamelCase(single.singularName)}Single.delete();
  },
};
`;
}
