/**
 * JSDoc type generator
 * Generates .js files with JSDoc annotations for type safety without TypeScript
 */

import path from 'node:path';
import type { ParsedSchema, CollectionType, SingleType, ComponentType, Attribute } from '@strapi2front/core';
import type { StrapiVersion } from '../../shared/types.js';
import { writeFile, ensureDir } from '../../utils/file.js';
import { toPascalCase, toKebabCase } from '../../utils/naming.js';
import { mapAttributeToType, getAttributeComment, extractDependencies } from '../../shared/type-mapper.js';

export interface JSDocTypesOptions {
  outputDir: string;
  blocksRendererInstalled?: boolean;
  strapiVersion?: StrapiVersion;
}

/**
 * Generate JSDoc types from parsed schema
 */
export async function generateJSDocTypes(
  schema: ParsedSchema,
  options: JSDocTypesOptions
): Promise<string[]> {
  const { outputDir } = options;
  const generatedFiles: string[] = [];

  // Ensure directories exist
  await ensureDir(path.join(outputDir, 'collections'));
  await ensureDir(path.join(outputDir, 'components'));

  // Generate utility types
  const utilsPath = path.join(outputDir, 'utils.js');
  const strapiVersion = options.strapiVersion ?? 'v5';
  await writeFile(utilsPath, generateUtilityTypes(strapiVersion));
  generatedFiles.push(utilsPath);

  // Generate collection types
  for (const collection of schema.collections) {
    const fileName = `${toKebabCase(collection.singularName)}.js`;
    const filePath = path.join(outputDir, 'collections', fileName);
    const content = generateCollectionType(collection, schema.components, strapiVersion);
    await writeFile(filePath, content);
    generatedFiles.push(filePath);
  }

  // Generate single types
  for (const single of schema.singles) {
    const fileName = `${toKebabCase(single.singularName)}.js`;
    const filePath = path.join(outputDir, 'collections', fileName);
    const content = generateSingleType(single, schema.components, strapiVersion);
    await writeFile(filePath, content);
    generatedFiles.push(filePath);
  }

  // Generate component types
  for (const component of schema.components) {
    const fileName = `${toKebabCase(component.name)}.js`;
    const filePath = path.join(outputDir, 'components', fileName);
    const content = generateComponentType(component, strapiVersion);
    await writeFile(filePath, content);
    generatedFiles.push(filePath);
  }

  return generatedFiles;
}

/**
 * Generate utility types with JSDoc
 */
function generateUtilityTypes(strapiVersion: StrapiVersion): string {
  const isV4 = strapiVersion === "v4";

  const baseEntityFields = isV4
    ? ` * @property {number} id
 * @property {string} createdAt
 * @property {string} updatedAt
 * @property {string|null} publishedAt`
    : ` * @property {number} id
 * @property {string} documentId
 * @property {string} createdAt
 * @property {string} updatedAt
 * @property {string|null} publishedAt`;

  const mediaFields = isV4
    ? ` * @property {number} id`
    : ` * @property {number} id
 * @property {string} documentId`;

  return `/**
 * Strapi utility types (JSDoc)
 * Generated by strapi2front
 * Strapi version: ${strapiVersion}
 *
 * These types provide IntelliSense support in JavaScript projects.
 */

/**
 * Strapi media format
 * @typedef {Object} StrapiMediaFormat
 * @property {string} name
 * @property {string} hash
 * @property {string} ext
 * @property {string} mime
 * @property {number} width
 * @property {number} height
 * @property {number} size
 * @property {string} url
 */

/**
 * Strapi media object
 * @typedef {Object} StrapiMedia
${mediaFields}
 * @property {string} name
 * @property {string|null} alternativeText
 * @property {string|null} caption
 * @property {number} width
 * @property {number} height
 * @property {{thumbnail?: StrapiMediaFormat, small?: StrapiMediaFormat, medium?: StrapiMediaFormat, large?: StrapiMediaFormat}|null} formats
 * @property {string} hash
 * @property {string} ext
 * @property {string} mime
 * @property {number} size
 * @property {string} url
 * @property {string|null} previewUrl
 * @property {string} provider
 * @property {string} createdAt
 * @property {string} updatedAt
 */

/**
 * Strapi pagination
 * @typedef {Object} StrapiPagination
 * @property {number} page
 * @property {number} pageSize
 * @property {number} pageCount
 * @property {number} total
 */

/**
 * Strapi response wrapper
 * @template T
 * @typedef {Object} StrapiResponse
 * @property {T} data
 * @property {{pagination?: StrapiPagination}} meta
 */

/**
 * Strapi list response
 * @template T
 * @typedef {Object} StrapiListResponse
 * @property {T[]} data
 * @property {{pagination: StrapiPagination}} meta
 */

/**
 * Base entity fields
 * @typedef {Object} StrapiBaseEntity
${baseEntityFields}
 */

/**
 * Blocks content type (rich text)
 * @typedef {unknown[]} BlocksContent
 */

// Export empty object to make this a module
export {};
`;
}

/**
 * Generate JSDoc type for a collection
 */
function generateCollectionType(
  collection: CollectionType,
  components: ComponentType[],
  strapiVersion: StrapiVersion
): string {
  const typeName = toPascalCase(collection.singularName);
  const isV4 = strapiVersion === "v4";
  const { relations, components: componentDeps } = extractDependencies(collection.attributes, typeName);

  // Generate imports
  const imports = generateJSDocImports(relations, componentDeps, 'collection');

  // Generate properties
  const properties = generateJSDocProperties(collection.attributes, components);

  // Base fields
  const baseFields = isV4
    ? ` * @property {number} id
 * @property {string} createdAt
 * @property {string} updatedAt
 * @property {string|null} publishedAt`
    : ` * @property {number} id
 * @property {string} documentId
 * @property {string} createdAt
 * @property {string} updatedAt
 * @property {string|null} publishedAt`;

  return `/**
 * ${collection.displayName}
 * ${collection.description || ''}
 * Generated by strapi2front
 * Strapi version: ${strapiVersion}
 */

${imports}

/**
 * ${collection.displayName}
 * @typedef {Object} ${typeName}
${baseFields}
${properties}
 */

/**
 * ${typeName} filters for querying
 * @typedef {Object} ${typeName}Filters
 * @property {number|{$eq?: number, $ne?: number, $in?: number[], $notIn?: number[]}} [id]
 * @property {string|{$eq?: string, $ne?: string}} [documentId]
 * @property {string|{$eq?: string, $gt?: string, $gte?: string, $lt?: string, $lte?: string}} [createdAt]
 * @property {string|{$eq?: string, $gt?: string, $gte?: string, $lt?: string, $lte?: string}} [updatedAt]
 * @property {string|null|{$eq?: string, $ne?: string, $null?: boolean}} [publishedAt]
 * @property {${typeName}Filters[]} [$and]
 * @property {${typeName}Filters[]} [$or]
 * @property {${typeName}Filters} [$not]
 */

// Export empty object to make this a module
export {};
`;
}

/**
 * Generate JSDoc type for a single type
 */
function generateSingleType(
  single: SingleType,
  components: ComponentType[],
  strapiVersion: StrapiVersion
): string {
  const typeName = toPascalCase(single.singularName);
  const isV4 = strapiVersion === "v4";
  const { relations, components: componentDeps } = extractDependencies(single.attributes, typeName);

  // Generate imports
  const imports = generateJSDocImports(relations, componentDeps, 'collection');

  // Generate properties
  const properties = generateJSDocProperties(single.attributes, components);

  // Base fields
  const baseFields = isV4
    ? ` * @property {number} id
 * @property {string} createdAt
 * @property {string} updatedAt`
    : ` * @property {number} id
 * @property {string} documentId
 * @property {string} createdAt
 * @property {string} updatedAt`;

  return `/**
 * ${single.displayName}
 * ${single.description || ''}
 * Generated by strapi2front
 * Strapi version: ${strapiVersion}
 */

${imports}

/**
 * ${single.displayName}
 * @typedef {Object} ${typeName}
${baseFields}
${properties}
 */

// Export empty object to make this a module
export {};
`;
}

/**
 * Generate JSDoc type for a component
 */
function generateComponentType(component: ComponentType, strapiVersion: StrapiVersion): string {
  const typeName = toPascalCase(component.name);
  const { relations, components: componentDeps } = extractDependencies(component.attributes, typeName);

  // Generate imports
  const imports = generateJSDocImports(relations, componentDeps, 'component');

  // Generate properties
  const properties = generateJSDocProperties(component.attributes, []);

  return `/**
 * ${component.displayName} component
 * Category: ${component.category}
 * ${component.description || ''}
 * Generated by strapi2front
 * Strapi version: ${strapiVersion}
 */

${imports}

/**
 * ${component.displayName}
 * @typedef {Object} ${typeName}
 * @property {number} id
${properties}
 */

// Export empty object to make this a module
export {};
`;
}

/**
 * Generate JSDoc imports
 */
function generateJSDocImports(
  relations: Set<string>,
  components: Set<string>,
  context: 'collection' | 'component'
): string {
  const imports: string[] = [];

  // Import from utils
  imports.push(`/** @typedef {import('../utils').StrapiMedia} StrapiMedia */`);
  imports.push(`/** @typedef {import('../utils').BlocksContent} BlocksContent */`);

  // Import relations
  for (const relation of relations) {
    const typeName = toPascalCase(relation);
    const fileName = toKebabCase(relation);
    if (context === 'component') {
      imports.push(`/** @typedef {import('../collections/${fileName}').${typeName}} ${typeName} */`);
    } else {
      imports.push(`/** @typedef {import('./${fileName}').${typeName}} ${typeName} */`);
    }
  }

  // Import components
  for (const component of components) {
    const typeName = toPascalCase(component);
    const fileName = toKebabCase(component);
    if (context === 'component') {
      imports.push(`/** @typedef {import('./${fileName}').${typeName}} ${typeName} */`);
    } else {
      imports.push(`/** @typedef {import('../components/${fileName}').${typeName}} ${typeName} */`);
    }
  }

  return imports.join('\n');
}

/**
 * Generate JSDoc properties from Strapi attributes
 */
function generateJSDocProperties(
  attributes: Record<string, Attribute>,
  components: ComponentType[]
): string {
  const lines: string[] = [];

  for (const [name, attr] of Object.entries(attributes)) {
    const mappedType = mapAttributeToType(attr, components);
    const jsDocType = convertToJSDocType(mappedType.type);
    const comment = getAttributeComment(attr);
    const commentPart = comment ? ` - ${comment}` : '';

    // In JSDoc, [name] indicates optional. Required fields don't use brackets.
    if (attr.required) {
      lines.push(` * @property {${jsDocType}} ${name}${commentPart}`);
    } else {
      lines.push(` * @property {${jsDocType}} [${name}]${commentPart}`);
    }
  }

  return lines.join('\n');
}

/**
 * Convert TypeScript type to JSDoc type
 */
function convertToJSDocType(tsType: string): string {
  // Handle union types with null
  if (tsType.includes(' | null')) {
    const baseType = tsType.replace(' | null', '');
    return `${baseType}|null`;
  }

  // Handle arrays
  if (tsType.endsWith('[]')) {
    const baseType = tsType.slice(0, -2);
    // Handle union arrays like (A | B)[]
    if (baseType.startsWith('(') && baseType.endsWith(')')) {
      return `Array<${baseType.slice(1, -1).replace(/ \| /g, '|')}>`;
    }
    return `${baseType}[]`;
  }

  // Handle string literal unions (enums)
  if (tsType.includes("'") && tsType.includes(' | ')) {
    return 'string';
  }

  return tsType;
}
