/**
 * Zod Schemas generator
 * Generates Zod validation schemas for Strapi content types
 */

import path from 'node:path';
import type { ParsedSchema, CollectionType, SingleType, ComponentType } from '@strapi2front/core';
import { formatCode } from '../../utils/formatter.js';
import { writeFile, ensureDir } from '../../utils/file.js';
import { toCamelCase, toKebabCase, toPascalCase } from '../../utils/naming.js';
import { generateZodObjectSchema, type ZodMapperOptions } from '../../shared/zod-mapper.js';

export interface ZodSchemasOptions {
  outputDir: string;
  /** Generate schemas alongside types in by-feature structure */
  byFeature?: boolean;
  /** Strapi version - affects ID types for relations (v4: number, v5: string) */
  strapiVersion?: 'v4' | 'v5';
}

export interface GeneratedSchemaInfo {
  /** File path where schema was written */
  filePath: string;
  /** Schema names generated */
  schemas: string[];
}

/**
 * Generate Zod schemas from parsed schema
 */
export async function generateZodSchemas(
  schema: ParsedSchema,
  options: ZodSchemasOptions
): Promise<GeneratedSchemaInfo[]> {
  const { outputDir, byFeature = false, strapiVersion = 'v5' } = options;
  const generatedFiles: GeneratedSchemaInfo[] = [];

  await ensureDir(outputDir);

  if (byFeature) {
    // Generate schemas in by-feature structure (alongside types and services)
    for (const collection of schema.collections) {
      const dirPath = path.join(outputDir, 'collections', toKebabCase(collection.singularName));
      await ensureDir(dirPath);

      const filePath = path.join(dirPath, 'schemas.ts');
      const content = generateCollectionSchemas(collection, schema.components, strapiVersion);
      await writeFile(filePath, await formatCode(content));

      generatedFiles.push({
        filePath,
        schemas: [
          `${toCamelCase(collection.singularName)}CreateSchema`,
          `${toCamelCase(collection.singularName)}UpdateSchema`,
        ],
      });
    }

    for (const single of schema.singles) {
      const dirPath = path.join(outputDir, 'singles', toKebabCase(single.singularName));
      await ensureDir(dirPath);

      const filePath = path.join(dirPath, 'schemas.ts');
      const content = generateSingleSchemas(single, schema.components, strapiVersion);
      await writeFile(filePath, await formatCode(content));

      generatedFiles.push({
        filePath,
        schemas: [`${toCamelCase(single.singularName)}UpdateSchema`],
      });
    }
  } else {
    // Generate all schemas in a single file
    const filePath = path.join(outputDir, 'schemas.ts');
    const content = generateAllSchemas(schema, strapiVersion);
    await writeFile(filePath, await formatCode(content));

    const allSchemas: string[] = [];
    for (const collection of schema.collections) {
      allSchemas.push(`${toCamelCase(collection.singularName)}CreateSchema`);
      allSchemas.push(`${toCamelCase(collection.singularName)}UpdateSchema`);
    }
    for (const single of schema.singles) {
      allSchemas.push(`${toCamelCase(single.singularName)}UpdateSchema`);
    }

    generatedFiles.push({ filePath, schemas: allSchemas });
  }

  return generatedFiles;
}

/**
 * Generate all schemas in a single file
 */
function generateAllSchemas(schema: ParsedSchema, strapiVersion: 'v4' | 'v5' = 'v5'): string {
  const sections: string[] = [];

  // Header
  sections.push(`/**
 * Zod Validation Schemas
 * Generated by strapi2front
 *
 * These schemas can be used for form validation, API input validation, etc.
 */

import { z } from 'zod';
`);

  // Collection schemas
  if (schema.collections.length > 0) {
    sections.push('// ============================================');
    sections.push('// Collection Schemas');
    sections.push('// ============================================\n');

    for (const collection of schema.collections) {
      sections.push(generateCollectionSchemaContent(collection, schema.components, strapiVersion));
      sections.push('');
    }
  }

  // Single type schemas
  if (schema.singles.length > 0) {
    sections.push('// ============================================');
    sections.push('// Single Type Schemas');
    sections.push('// ============================================\n');

    for (const single of schema.singles) {
      sections.push(generateSingleSchemaContent(single, schema.components, strapiVersion));
      sections.push('');
    }
  }

  // Export all schemas
  sections.push('// ============================================');
  sections.push('// Schema Exports');
  sections.push('// ============================================\n');

  const exports: string[] = [];
  for (const collection of schema.collections) {
    const name = toCamelCase(collection.singularName);
    exports.push(`  ${name}CreateSchema,`);
    exports.push(`  ${name}UpdateSchema,`);
  }
  for (const single of schema.singles) {
    const name = toCamelCase(single.singularName);
    exports.push(`  ${name}UpdateSchema,`);
  }

  sections.push(`export const schemas = {\n${exports.join('\n')}\n};`);

  return sections.join('\n');
}

/**
 * Generate schemas for a collection type (separate file)
 */
function generateCollectionSchemas(
  collection: CollectionType,
  _components: ComponentType[],
  strapiVersion: 'v4' | 'v5' = 'v5'
): string {
  const name = toCamelCase(collection.singularName);
  const pascalName = toPascalCase(collection.singularName);

  return `/**
 * ${collection.displayName} Zod Schemas
 * ${collection.description || ''}
 * Generated by strapi2front
 */

import { z } from 'zod';

${generateCollectionSchemaContent(collection, _components, strapiVersion)}

// Type inference helpers
export type ${pascalName}CreateInput = z.infer<typeof ${name}CreateSchema>;
export type ${pascalName}UpdateInput = z.infer<typeof ${name}UpdateSchema>;
`;
}

/**
 * Generate schemas for a single type (separate file)
 */
function generateSingleSchemas(
  single: SingleType,
  _components: ComponentType[],
  strapiVersion: 'v4' | 'v5' = 'v5'
): string {
  const name = toCamelCase(single.singularName);
  const pascalName = toPascalCase(single.singularName);

  return `/**
 * ${single.displayName} Zod Schemas
 * ${single.description || ''}
 * Generated by strapi2front
 */

import { z } from 'zod';

${generateSingleSchemaContent(single, _components, strapiVersion)}

// Type inference helpers
export type ${pascalName}UpdateInput = z.infer<typeof ${name}UpdateSchema>;
`;
}

/**
 * Generate schema content for a collection
 */
function generateCollectionSchemaContent(
  collection: CollectionType,
  _components: ComponentType[],
  strapiVersion: 'v4' | 'v5' = 'v5'
): string {
  const name = toCamelCase(collection.singularName);
  const sections: string[] = [];

  // Create schema options
  const createOptions: ZodMapperOptions = {
    isUpdate: false,
    includeRelations: true,
    includeMedia: true,
    includeComponents: true,
    strapiVersion,
  };

  // Update schema options (all fields optional)
  const updateOptions: ZodMapperOptions = {
    isUpdate: true,
    includeRelations: true,
    includeMedia: true,
    includeComponents: true,
    strapiVersion,
  };

  // Generate create schema
  const createResult = generateZodObjectSchema(collection.attributes, createOptions);
  sections.push(`/**
 * Schema for creating a new ${collection.displayName}
 */
export const ${name}CreateSchema = ${createResult.schema};`);

  // Add comments about skipped fields if any
  if (createResult.skippedFields.length > 0) {
    sections.push(`// Skipped fields: ${createResult.skippedFields.map((f) => f.name).join(', ')}`);
  }

  sections.push('');

  // Generate update schema (all fields optional)
  const updateResult = generateZodObjectSchema(collection.attributes, updateOptions);
  sections.push(`/**
 * Schema for updating a ${collection.displayName}
 * All fields are optional for partial updates
 */
export const ${name}UpdateSchema = ${updateResult.schema};`);

  return sections.join('\n');
}

/**
 * Generate schema content for a single type
 */
function generateSingleSchemaContent(
  single: SingleType,
  _components: ComponentType[],
  strapiVersion: 'v4' | 'v5' = 'v5'
): string {
  const name = toCamelCase(single.singularName);

  // Update schema options (all fields optional for single types)
  const updateOptions: ZodMapperOptions = {
    isUpdate: true,
    includeRelations: true,
    includeMedia: true,
    includeComponents: true,
    strapiVersion,
  };

  const updateResult = generateZodObjectSchema(single.attributes, updateOptions);

  return `/**
 * Schema for updating ${single.displayName}
 * All fields are optional for partial updates
 */
export const ${name}UpdateSchema = ${updateResult.schema};`;
}
