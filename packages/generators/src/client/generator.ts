import path from 'node:path';
import { formatCode } from '../utils/formatter.js';
import { writeFile, ensureDir } from '../utils/file.js';

export interface ClientGeneratorOptions {
  outputDir: string;
  strapiVersion?: "v4" | "v5";
}

/**
 * Generate the Strapi client file
 */
export async function generateClient(
  options: ClientGeneratorOptions
): Promise<string[]> {
  const { outputDir, strapiVersion = "v5" } = options;
  const generatedFiles: string[] = [];

  await ensureDir(outputDir);

  const filePath = path.join(outputDir, 'client.ts');
  const content = generateClientFile(strapiVersion);
  await writeFile(filePath, await formatCode(content));
  generatedFiles.push(filePath);

  return generatedFiles;
}

/**
 * Generate the client file content
 */
function generateClientFile(strapiVersion: "v4" | "v5"): string {
  const isV4 = strapiVersion === "v4";

  if (isV4) {
    return generateV4ClientFile();
  }
  return generateV5ClientFile();
}

/**
 * Generate client for Strapi v5 (flat response structure)
 */
function generateV5ClientFile(): string {
  return `/**
 * Strapi Client (v5)
 * Generated by strapi-integrate
 */

import Strapi from 'strapi-sdk-js';

// Initialize the Strapi client
const strapiUrl = import.meta.env.STRAPI_URL || process.env.STRAPI_URL || 'http://localhost:1337';
const strapiToken = import.meta.env.STRAPI_TOKEN || process.env.STRAPI_TOKEN;

export const strapi = new Strapi({
  url: strapiUrl,
  axiosOptions: {
    headers: strapiToken ? {
      Authorization: \`Bearer \${strapiToken}\`,
    } : {},
  },
});

// Pagination type
export interface StrapiPagination {
  page: number;
  pageSize: number;
  pageCount: number;
  total: number;
}

// Default pagination for fallback
const defaultPagination: StrapiPagination = {
  page: 1,
  pageSize: 25,
  pageCount: 1,
  total: 0,
};

// Response types
interface StrapiListResponse<T> {
  data: T[];
  meta: {
    pagination?: StrapiPagination;
  };
}

interface StrapiSingleResponse<T> {
  data: T;
  meta?: Record<string, unknown>;
}

// Helper to get typed collection
export function collection<T>(pluralName: string) {
  return {
    async find(params?: Record<string, unknown>): Promise<{ data: T[]; meta: { pagination: StrapiPagination } }> {
      const response = await strapi.find(pluralName, params) as unknown as StrapiListResponse<T>;
      return {
        data: Array.isArray(response.data) ? response.data : [],
        meta: {
          pagination: response.meta?.pagination || defaultPagination,
        },
      };
    },
    async findOne(documentId: string, params?: Record<string, unknown>): Promise<{ data: T }> {
      const response = await strapi.findOne(pluralName, documentId, params) as unknown as StrapiSingleResponse<T>;
      return { data: response.data };
    },
    async create(data: { data: Partial<T> }): Promise<{ data: T }> {
      const response = await strapi.create(pluralName, data.data as Record<string, unknown>) as unknown as StrapiSingleResponse<T>;
      return { data: response.data };
    },
    async update(documentId: string, data: { data: Partial<T> }): Promise<{ data: T }> {
      const response = await strapi.update(pluralName, documentId, data.data as Record<string, unknown>) as unknown as StrapiSingleResponse<T>;
      return { data: response.data };
    },
    async delete(documentId: string): Promise<void> {
      await strapi.delete(pluralName, documentId);
    },
  };
}

// Helper to get typed single type
export function single<T>(singularName: string) {
  return {
    async find(params?: Record<string, unknown>): Promise<{ data: T }> {
      const response = await strapi.find(singularName, params) as unknown as StrapiSingleResponse<T>;
      return { data: response.data };
    },
    async update(data: { data: Partial<T> }): Promise<{ data: T }> {
      const response = await strapi.update(singularName, 1 as unknown as string, data.data as Record<string, unknown>) as unknown as StrapiSingleResponse<T>;
      return { data: response.data };
    },
    async delete(): Promise<void> {
      await strapi.delete(singularName, 1 as unknown as string);
    },
  };
}
`;
}

/**
 * Generate client for Strapi v4 (nested attributes structure)
 */
function generateV4ClientFile(): string {
  return `/**
 * Strapi Client (v4)
 * Generated by strapi-integrate
 */

import Strapi from 'strapi-sdk-js';

// Initialize the Strapi client
const strapiUrl = import.meta.env.STRAPI_URL || process.env.STRAPI_URL || 'http://localhost:1337';
const strapiToken = import.meta.env.STRAPI_TOKEN || process.env.STRAPI_TOKEN;

export const strapi = new Strapi({
  url: strapiUrl,
  axiosOptions: {
    headers: strapiToken ? {
      Authorization: \`Bearer \${strapiToken}\`,
    } : {},
  },
});

// Pagination type
export interface StrapiPagination {
  page: number;
  pageSize: number;
  pageCount: number;
  total: number;
}

// Default pagination for fallback
const defaultPagination: StrapiPagination = {
  page: 1,
  pageSize: 25,
  pageCount: 1,
  total: 0,
};

// Strapi v4 raw response types (with nested attributes)
interface StrapiV4RawItem<T> {
  id: number;
  attributes: Omit<T, 'id'>;
}

interface StrapiV4RawListResponse<T> {
  data: StrapiV4RawItem<T>[];
  meta: {
    pagination?: StrapiPagination;
  };
}

interface StrapiV4RawSingleResponse<T> {
  data: StrapiV4RawItem<T>;
  meta?: Record<string, unknown>;
}

/**
 * Flatten a Strapi v4 response item (merges id with attributes)
 */
function flattenItem<T>(item: StrapiV4RawItem<T>): T {
  return { id: item.id, ...item.attributes } as T;
}

/**
 * Recursively flatten nested relations in Strapi v4 response
 */
function flattenRelations<T>(data: T): T {
  if (data === null || data === undefined) return data;
  if (Array.isArray(data)) {
    return data.map(item => flattenRelations(item)) as unknown as T;
  }
  if (typeof data === 'object') {
    const result: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(data as Record<string, unknown>)) {
      // Check if this is a Strapi v4 relation response { data: { id, attributes } }
      if (value && typeof value === 'object' && 'data' in value) {
        const relationData = (value as { data: unknown }).data;
        if (relationData === null) {
          result[key] = null;
        } else if (Array.isArray(relationData)) {
          // To-many relation
          result[key] = relationData.map((item: StrapiV4RawItem<unknown>) =>
            flattenRelations(flattenItem(item))
          );
        } else if (typeof relationData === 'object' && 'id' in relationData && 'attributes' in relationData) {
          // To-one relation
          result[key] = flattenRelations(flattenItem(relationData as StrapiV4RawItem<unknown>));
        } else {
          result[key] = flattenRelations(value);
        }
      } else {
        result[key] = flattenRelations(value);
      }
    }
    return result as T;
  }
  return data;
}

// Helper to get typed collection
export function collection<T>(pluralName: string) {
  return {
    async find(params?: Record<string, unknown>): Promise<{ data: T[]; meta: { pagination: StrapiPagination } }> {
      const response = await strapi.find(pluralName, params) as unknown as StrapiV4RawListResponse<T>;
      const flattenedData = Array.isArray(response.data)
        ? response.data.map(item => flattenRelations(flattenItem<T>(item)))
        : [];
      return {
        data: flattenedData,
        meta: {
          pagination: response.meta?.pagination || defaultPagination,
        },
      };
    },
    async findOne(id: number | string, params?: Record<string, unknown>): Promise<{ data: T }> {
      const response = await strapi.findOne(pluralName, String(id), params) as unknown as StrapiV4RawSingleResponse<T>;
      return { data: flattenRelations(flattenItem<T>(response.data)) };
    },
    async create(data: { data: Partial<T> }): Promise<{ data: T }> {
      const response = await strapi.create(pluralName, data.data as Record<string, unknown>) as unknown as StrapiV4RawSingleResponse<T>;
      return { data: flattenRelations(flattenItem<T>(response.data)) };
    },
    async update(id: number | string, data: { data: Partial<T> }): Promise<{ data: T }> {
      const response = await strapi.update(pluralName, String(id), data.data as Record<string, unknown>) as unknown as StrapiV4RawSingleResponse<T>;
      return { data: flattenRelations(flattenItem<T>(response.data)) };
    },
    async delete(id: number | string): Promise<void> {
      await strapi.delete(pluralName, String(id));
    },
  };
}

// Helper to get typed single type
export function single<T>(singularName: string) {
  return {
    async find(params?: Record<string, unknown>): Promise<{ data: T }> {
      const response = await strapi.find(singularName, params) as unknown as StrapiV4RawSingleResponse<T>;
      return { data: flattenRelations(flattenItem<T>(response.data)) };
    },
    async update(data: { data: Partial<T> }): Promise<{ data: T }> {
      const response = await strapi.update(singularName, 1 as unknown as string, data.data as Record<string, unknown>) as unknown as StrapiV4RawSingleResponse<T>;
      return { data: flattenRelations(flattenItem<T>(response.data)) };
    },
    async delete(): Promise<void> {
      await strapi.delete(singularName, 1 as unknown as string);
    },
  };
}
`;
}
