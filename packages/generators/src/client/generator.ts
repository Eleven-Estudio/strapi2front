import path from 'node:path';
import { formatCode } from '../utils/formatter.js';
import { writeFile, ensureDir } from '../utils/file.js';

export interface ClientGeneratorOptions {
  outputDir: string;
}

/**
 * Generate the Strapi client file
 */
export async function generateClient(
  options: ClientGeneratorOptions
): Promise<string[]> {
  const { outputDir } = options;
  const generatedFiles: string[] = [];

  await ensureDir(outputDir);

  const filePath = path.join(outputDir, 'client.ts');
  const content = generateClientFile();
  await writeFile(filePath, await formatCode(content));
  generatedFiles.push(filePath);

  return generatedFiles;
}

/**
 * Generate the client file content
 */
function generateClientFile(): string {
  return `/**
 * Strapi Client
 * Generated by strapi-integrate
 */

import Strapi from 'strapi-sdk-js';

// Initialize the Strapi client
const strapiUrl = import.meta.env.STRAPI_URL || process.env.STRAPI_URL || 'http://localhost:1337';
const strapiToken = import.meta.env.STRAPI_TOKEN || process.env.STRAPI_TOKEN;

export const strapi = new Strapi({
  url: strapiUrl,
  axiosOptions: {
    headers: strapiToken ? {
      Authorization: \`Bearer \${strapiToken}\`,
    } : {},
  },
});

// Pagination type
export interface StrapiPagination {
  page: number;
  pageSize: number;
  pageCount: number;
  total: number;
}

// Default pagination for fallback
const defaultPagination: StrapiPagination = {
  page: 1,
  pageSize: 25,
  pageCount: 1,
  total: 0,
};

// Response types
interface StrapiListResponse<T> {
  data: T[];
  meta: {
    pagination?: StrapiPagination;
  };
}

interface StrapiSingleResponse<T> {
  data: T;
  meta?: Record<string, unknown>;
}

// Helper to get typed collection
export function collection<T>(pluralName: string) {
  return {
    async find(params?: Record<string, unknown>): Promise<{ data: T[]; meta: { pagination: StrapiPagination } }> {
      const response = await strapi.find(pluralName, params) as unknown as StrapiListResponse<T>;
      return {
        data: Array.isArray(response.data) ? response.data : [],
        meta: {
          pagination: response.meta?.pagination || defaultPagination,
        },
      };
    },
    async findOne(documentId: string, params?: Record<string, unknown>): Promise<{ data: T }> {
      const response = await strapi.findOne(pluralName, documentId, params) as unknown as StrapiSingleResponse<T>;
      return { data: response.data };
    },
    async create(data: { data: Partial<T> }): Promise<{ data: T }> {
      const response = await strapi.create(pluralName, data.data as Record<string, unknown>) as unknown as StrapiSingleResponse<T>;
      return { data: response.data };
    },
    async update(documentId: string, data: { data: Partial<T> }): Promise<{ data: T }> {
      const response = await strapi.update(pluralName, documentId, data.data as Record<string, unknown>) as unknown as StrapiSingleResponse<T>;
      return { data: response.data };
    },
    async delete(documentId: string): Promise<void> {
      await strapi.delete(pluralName, documentId);
    },
  };
}

// Helper to get typed single type
export function single<T>(singularName: string) {
  return {
    async find(params?: Record<string, unknown>): Promise<{ data: T }> {
      const response = await strapi.find(singularName, params) as unknown as StrapiSingleResponse<T>;
      return { data: response.data };
    },
    async update(data: { data: Partial<T> }): Promise<{ data: T }> {
      const response = await strapi.update(singularName, 1 as unknown as string, data.data as Record<string, unknown>) as unknown as StrapiSingleResponse<T>;
      return { data: response.data };
    },
    async delete(): Promise<void> {
      await strapi.delete(singularName, 1 as unknown as string);
    },
  };
}
`;
}
