import path from 'node:path';
import { formatCode } from '../utils/formatter.js';
import { writeFile, ensureDir } from '../utils/file.js';

export interface ClientGeneratorOptions {
  outputDir: string;
  strapiVersion?: "v4" | "v5";
  apiPrefix?: string;
}

/**
 * Generate the Strapi client file
 */
export async function generateClient(
  options: ClientGeneratorOptions
): Promise<string[]> {
  const { outputDir, strapiVersion = "v5", apiPrefix = "/api" } = options;
  const generatedFiles: string[] = [];

  await ensureDir(outputDir);

  const filePath = path.join(outputDir, 'client.ts');
  const content = generateClientFile(strapiVersion, apiPrefix);
  await writeFile(filePath, await formatCode(content));
  generatedFiles.push(filePath);

  return generatedFiles;
}

/**
 * Generate the client file content
 */
function generateClientFile(strapiVersion: "v4" | "v5", apiPrefix: string): string {
  const isV4 = strapiVersion === "v4";

  if (isV4) {
    return generateV4ClientFile(apiPrefix);
  }
  return generateV5ClientFile(apiPrefix);
}

/**
 * Generate client for Strapi v5 (flat response structure)
 */
function generateV5ClientFile(apiPrefix: string): string {
  // Normalize prefix for the generated code
  const normalizedPrefix = apiPrefix.startsWith('/') ? apiPrefix : '/' + apiPrefix;

  return `/**
 * Strapi Client (v5)
 * Generated by strapi2front
 *
 * Using official @strapi/client
 * @see https://docs.strapi.io/cms/api/client
 */

import { strapi } from '@strapi/client';

// Initialize the Strapi client
const baseURL = (import.meta.env.STRAPI_URL || process.env.STRAPI_URL || 'http://localhost:1337') + '${normalizedPrefix}';
const authToken = import.meta.env.STRAPI_TOKEN || process.env.STRAPI_TOKEN;

export const strapiClient = strapi({
  baseURL,
  auth: authToken,
});

// Pagination type
export interface StrapiPagination {
  page: number;
  pageSize: number;
  pageCount: number;
  total: number;
}

// Media types
export interface StrapiMediaFormat {
  name: string;
  hash: string;
  ext: string;
  mime: string;
  width: number;
  height: number;
  size: number;
  url: string;
}

export interface StrapiMedia {
  id: number;
  documentId: string;
  name: string;
  alternativeText: string | null;
  caption: string | null;
  width: number;
  height: number;
  formats: {
    thumbnail?: StrapiMediaFormat;
    small?: StrapiMediaFormat;
    medium?: StrapiMediaFormat;
    large?: StrapiMediaFormat;
  } | null;
  hash: string;
  ext: string;
  mime: string;
  size: number;
  url: string;
  previewUrl: string | null;
  provider: string;
  createdAt: string;
  updatedAt: string;
}

/**
 * File metadata for uploads
 * @see https://docs.strapi.io/cms/api/client#upload
 */
export interface StrapiFileInfo {
  name?: string;
  alternativeText?: string;
  caption?: string;
}

// Default pagination for fallback
const defaultPagination: StrapiPagination = {
  page: 1,
  pageSize: 25,
  pageCount: 1,
  total: 0,
};

// Helper to get typed collection
export function collection<T>(pluralName: string) {
  const col = strapiClient.collection(pluralName);
  return {
    async find(params?: Record<string, unknown>): Promise<{ data: T[]; meta: { pagination: StrapiPagination } }> {
      const response = await col.find(params) as any;
      return {
        data: Array.isArray(response.data) ? response.data : [],
        meta: {
          pagination: response.meta?.pagination || defaultPagination,
        },
      };
    },
    async findOne(documentId: string, params?: Record<string, unknown>): Promise<{ data: T }> {
      const response = await col.findOne(documentId, params) as any;
      return { data: response.data };
    },
    async create(data: Partial<T>): Promise<{ data: T }> {
      const response = await col.create(data as any) as any;
      return { data: response.data };
    },
    async update(documentId: string, data: Partial<T>): Promise<{ data: T }> {
      const response = await col.update(documentId, data as any) as any;
      return { data: response.data };
    },
    async delete(documentId: string): Promise<void> {
      await col.delete(documentId);
    },
  };
}

// Helper to get typed single type
export function single<T>(singularName: string) {
  const singleType = strapiClient.single(singularName);
  return {
    async find(params?: Record<string, unknown>): Promise<{ data: T }> {
      const response = await singleType.find(params) as any;
      return { data: response.data };
    },
    async update(data: Partial<T>): Promise<{ data: T }> {
      const response = await singleType.update(data as any) as any;
      return { data: response.data };
    },
    async delete(): Promise<void> {
      await singleType.delete();
    },
  };
}

/**
 * File management helpers
 * Wraps @strapi/client file methods with proper typing
 * @see https://docs.strapi.io/cms/api/client#working-with-files
 */
export const files = {
  async upload(file: File | Blob, options?: { fileInfo?: StrapiFileInfo }): Promise<StrapiMedia> {
    const response = await strapiClient.files.upload(file, options) as any;
    return response;
  },
  async find(params?: Record<string, unknown>): Promise<StrapiMedia[]> {
    const response = await strapiClient.files.find(params) as any;
    return Array.isArray(response) ? response : [];
  },
  async findOne(fileId: number): Promise<StrapiMedia> {
    const response = await strapiClient.files.findOne(fileId) as any;
    return response;
  },
  async update(fileId: number, fileInfo: StrapiFileInfo): Promise<StrapiMedia> {
    const response = await strapiClient.files.update(fileId, fileInfo) as any;
    return response;
  },
  async delete(fileId: number): Promise<StrapiMedia> {
    const response = await strapiClient.files.delete(fileId) as any;
    return response;
  },
};
`;
}

/**
 * Generate client for Strapi v4 (nested attributes structure)
 */
function generateV4ClientFile(apiPrefix: string): string {
  // Normalize prefix for the generated code
  const normalizedPrefix = apiPrefix.startsWith('/') ? apiPrefix : '/' + apiPrefix;

  return `/**
 * Strapi Client (v4)
 * Generated by strapi2front
 *
 * Note: @strapi/client officially supports Strapi v5+
 * This v4 client uses a compatibility layer for the nested attributes structure
 */

import { strapi as createStrapi } from '@strapi/client';

// Initialize the Strapi client
const baseURL = (import.meta.env.STRAPI_URL || process.env.STRAPI_URL || 'http://localhost:1337') + '${normalizedPrefix}';
const authToken = import.meta.env.STRAPI_TOKEN || process.env.STRAPI_TOKEN;

export const strapiClient = createStrapi({
  baseURL,
  auth: authToken,
});

// Pagination type
export interface StrapiPagination {
  page: number;
  pageSize: number;
  pageCount: number;
  total: number;
}

// Media types
export interface StrapiMediaFormat {
  name: string;
  hash: string;
  ext: string;
  mime: string;
  width: number;
  height: number;
  size: number;
  url: string;
}

export interface StrapiMedia {
  id: number;
  name: string;
  alternativeText: string | null;
  caption: string | null;
  width: number;
  height: number;
  formats: {
    thumbnail?: StrapiMediaFormat;
    small?: StrapiMediaFormat;
    medium?: StrapiMediaFormat;
    large?: StrapiMediaFormat;
  } | null;
  hash: string;
  ext: string;
  mime: string;
  size: number;
  url: string;
  previewUrl: string | null;
  provider: string;
  createdAt: string;
  updatedAt: string;
}

/**
 * File metadata for uploads
 * @see https://docs.strapi.io/cms/api/client#upload
 */
export interface StrapiFileInfo {
  name?: string;
  alternativeText?: string;
  caption?: string;
}

// Default pagination for fallback
const defaultPagination: StrapiPagination = {
  page: 1,
  pageSize: 25,
  pageCount: 1,
  total: 0,
};

// Strapi v4 raw response types (with nested attributes)
interface StrapiV4RawItem<T> {
  id: number;
  attributes: Omit<T, 'id'>;
}

/**
 * Flatten a Strapi v4 response item (merges id with attributes)
 */
function flattenItem<T>(item: StrapiV4RawItem<T>): T {
  return { id: item.id, ...item.attributes } as T;
}

/**
 * Recursively flatten nested relations in Strapi v4 response
 */
function flattenRelations<T>(data: T): T {
  if (data === null || data === undefined) return data;
  if (Array.isArray(data)) {
    return data.map(item => flattenRelations(item)) as unknown as T;
  }
  if (typeof data === 'object') {
    const result: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(data as Record<string, unknown>)) {
      // Check if this is a Strapi v4 relation response { data: { id, attributes } }
      if (value && typeof value === 'object' && 'data' in value) {
        const relationData = (value as { data: unknown }).data;
        if (relationData === null) {
          result[key] = null;
        } else if (Array.isArray(relationData)) {
          // To-many relation
          result[key] = relationData.map((item: StrapiV4RawItem<unknown>) =>
            flattenRelations(flattenItem(item))
          );
        } else if (typeof relationData === 'object' && 'id' in relationData && 'attributes' in relationData) {
          // To-one relation
          result[key] = flattenRelations(flattenItem(relationData as StrapiV4RawItem<unknown>));
        } else {
          result[key] = flattenRelations(value);
        }
      } else {
        result[key] = flattenRelations(value);
      }
    }
    return result as T;
  }
  return data;
}

// Helper to get typed collection (v4 compatibility wrapper)
export function collection<T>(pluralName: string) {
  const col = strapiClient.collection(pluralName);
  return {
    async find(params?: Record<string, unknown>): Promise<{ data: T[]; meta: { pagination: StrapiPagination } }> {
      const response = await col.find(params) as any;
      const flattenedData = Array.isArray(response.data)
        ? response.data.map((item: StrapiV4RawItem<T>) => flattenRelations(flattenItem<T>(item)))
        : [];
      return {
        data: flattenedData,
        meta: { pagination: response.meta?.pagination || defaultPagination },
      };
    },
    async findOne(id: number | string, params?: Record<string, unknown>): Promise<{ data: T }> {
      const response = await col.findOne(String(id), params) as any;
      return { data: flattenRelations(flattenItem<T>(response.data)) };
    },
    async create(data: Partial<T>): Promise<{ data: T }> {
      const response = await col.create(data as any) as any;
      return { data: flattenRelations(flattenItem<T>(response.data)) };
    },
    async update(id: number | string, data: Partial<T>): Promise<{ data: T }> {
      const response = await col.update(String(id), data as any) as any;
      return { data: flattenRelations(flattenItem<T>(response.data)) };
    },
    async delete(id: number | string): Promise<void> {
      await col.delete(String(id));
    },
  };
}

// Helper to get typed single type (v4 compatibility wrapper)
export function single<T>(singularName: string) {
  const singleType = strapiClient.single(singularName);
  return {
    async find(params?: Record<string, unknown>): Promise<{ data: T }> {
      const response = await singleType.find(params) as any;
      return { data: flattenRelations(flattenItem<T>(response.data)) };
    },
    async update(data: Partial<T>): Promise<{ data: T }> {
      const response = await singleType.update(data as any) as any;
      return { data: flattenRelations(flattenItem<T>(response.data)) };
    },
    async delete(): Promise<void> {
      await singleType.delete();
    },
  };
}

/**
 * File management helpers
 * Wraps @strapi/client file methods with proper typing
 * @see https://docs.strapi.io/cms/api/client#working-with-files
 */
export const files = {
  async upload(file: File | Blob, options?: { fileInfo?: StrapiFileInfo }): Promise<StrapiMedia> {
    const response = await strapiClient.files.upload(file, options) as any;
    return response;
  },
  async find(params?: Record<string, unknown>): Promise<StrapiMedia[]> {
    const response = await strapiClient.files.find(params) as any;
    return Array.isArray(response) ? response : [];
  },
  async findOne(fileId: number): Promise<StrapiMedia> {
    const response = await strapiClient.files.findOne(fileId) as any;
    return response;
  },
  async update(fileId: number, fileInfo: StrapiFileInfo): Promise<StrapiMedia> {
    const response = await strapiClient.files.update(fileId, fileInfo) as any;
    return response;
  },
  async delete(fileId: number): Promise<StrapiMedia> {
    const response = await strapiClient.files.delete(fileId) as any;
    return response;
  },
};
`;
}
