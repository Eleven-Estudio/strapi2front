import path from 'node:path';
import type { ParsedSchema, CollectionType, SingleType } from '@strapi2front/core';
import { formatCode } from '../utils/formatter.js';
import { writeFile, ensureDir } from '../utils/file.js';
import { toCamelCase, toKebabCase } from '../utils/naming.js';

export interface ActionsGeneratorOptions {
  outputDir: string;
  servicesImportPath: string;
  strapiVersion?: "v4" | "v5";
}

/**
 * Generate Astro Actions from parsed schema
 */
export async function generateActions(
  schema: ParsedSchema,
  options: ActionsGeneratorOptions
): Promise<string[]> {
  const { outputDir, servicesImportPath, strapiVersion = "v5" } = options;
  const generatedFiles: string[] = [];

  await ensureDir(outputDir);

  // Generate actions for collections
  for (const collection of schema.collections) {
    const fileName = `${toKebabCase(collection.singularName)}.ts`;
    const filePath = path.join(outputDir, fileName);
    const content = generateCollectionActions(collection, servicesImportPath, strapiVersion);
    await writeFile(filePath, await formatCode(content));
    generatedFiles.push(filePath);
  }

  // Generate actions for single types
  for (const single of schema.singles) {
    const fileName = `${toKebabCase(single.singularName)}.ts`;
    const filePath = path.join(outputDir, fileName);
    const content = generateSingleActions(single, servicesImportPath);
    await writeFile(filePath, await formatCode(content));
    generatedFiles.push(filePath);
  }

  return generatedFiles;
}

/**
 * Generate actions for a collection type
 */
function generateCollectionActions(
  collection: CollectionType,
  servicesImportPath: string,
  strapiVersion: "v4" | "v5"
): string {
  const serviceName = toCamelCase(collection.singularName) + 'Service';
  const actionsName = toCamelCase(collection.singularName);
  const fileName = toKebabCase(collection.singularName);
  const isV4 = strapiVersion === "v4";

  // V4 uses `id: number`, V5 uses `documentId: string`
  const idInputSchema = isV4 ? 'z.number().int().positive()' : 'z.string().min(1)';
  const idParamName = isV4 ? 'id' : 'documentId';
  const idComment = isV4 ? 'id' : 'documentId';

  // Detect if collection has a slug field
  const hasSlug = 'slug' in collection.attributes;

  return `/**
 * ${collection.displayName} Actions
 * ${collection.description || ''}
 * Generated by strapi2front
 * Strapi version: ${strapiVersion}
 */

import { defineAction, ActionError } from 'astro:actions';
import { z } from 'astro:schema';
import { ${serviceName} } from '${servicesImportPath}/${fileName}.service';

/**
 * Pagination input schema
 */
const paginationSchema = z.object({
  page: z.number().int().positive().optional().default(1),
  pageSize: z.number().int().positive().max(100).optional().default(25),
}).optional();

/**
 * ${collection.displayName} actions
 */
export const ${actionsName} = {
  /**
   * Get all ${collection.pluralName} with pagination
   */
  getAll: defineAction({
    input: z.object({
      pagination: paginationSchema,
      sort: z.union([z.string(), z.array(z.string())]).optional(),
    }).optional(),
    handler: async (input) => {
      try {
        const result = await ${serviceName}.findMany({
          pagination: input?.pagination,
          sort: input?.sort,
        });

        return result;
      } catch (error) {
        throw new ActionError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to fetch ${collection.pluralName}',
        });
      }
    },
  }),

  /**
   * Get a single ${collection.singularName} by ${idComment}
   */
  getOne: defineAction({
    input: z.object({
      ${idParamName}: ${idInputSchema},
      populate: z.union([z.string(), z.array(z.string())]).optional(),
    }),
    handler: async ({ ${idParamName}, populate }) => {
      try {
        const result = await ${serviceName}.findOne(${idParamName}, { populate });

        if (!result) {
          throw new ActionError({
            code: 'NOT_FOUND',
            message: '${collection.displayName} not found',
          });
        }

        return result;
      } catch (error) {
        if (error instanceof ActionError) throw error;
        throw new ActionError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to fetch ${collection.singularName}',
        });
      }
    },
  }),
${hasSlug ? `
  /**
   * Get a single ${collection.singularName} by slug
   */
  getBySlug: defineAction({
    input: z.object({
      slug: z.string().min(1),
      populate: z.union([z.string(), z.array(z.string())]).optional(),
    }),
    handler: async ({ slug, populate }) => {
      try {
        const result = await ${serviceName}.findBySlug(slug, { populate });

        if (!result) {
          throw new ActionError({
            code: 'NOT_FOUND',
            message: '${collection.displayName} not found',
          });
        }

        return result;
      } catch (error) {
        if (error instanceof ActionError) throw error;
        throw new ActionError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to fetch ${collection.singularName}',
        });
      }
    },
  }),
` : ''}
  /**
   * Create a new ${collection.singularName}
   */
  create: defineAction({
    input: z.object({
      data: z.record(z.unknown()),
    }),
    handler: async ({ data }) => {
      try {
        const result = await ${serviceName}.create(data);
        return result;
      } catch (error) {
        throw new ActionError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to create ${collection.singularName}',
        });
      }
    },
  }),

  /**
   * Update a ${collection.singularName}
   */
  update: defineAction({
    input: z.object({
      ${idParamName}: ${idInputSchema},
      data: z.record(z.unknown()),
    }),
    handler: async ({ ${idParamName}, data }) => {
      try {
        const result = await ${serviceName}.update(${idParamName}, data);
        return result;
      } catch (error) {
        throw new ActionError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to update ${collection.singularName}',
        });
      }
    },
  }),

  /**
   * Delete a ${collection.singularName}
   */
  delete: defineAction({
    input: z.object({
      ${idParamName}: ${idInputSchema},
    }),
    handler: async ({ ${idParamName} }) => {
      try {
        await ${serviceName}.delete(${idParamName});
        return { success: true };
      } catch (error) {
        throw new ActionError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to delete ${collection.singularName}',
        });
      }
    },
  }),

  /**
   * Count ${collection.pluralName}
   */
  count: defineAction({
    input: z.object({
      filters: z.record(z.unknown()).optional(),
    }).optional(),
    handler: async (input) => {
      try {
        const count = await ${serviceName}.count(input?.filters as any);
        return { count };
      } catch (error) {
        throw new ActionError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to count ${collection.pluralName}',
        });
      }
    },
  }),
};
`;
}

/**
 * Generate actions for a single type
 */
function generateSingleActions(
  single: SingleType,
  servicesImportPath: string
): string {
  const serviceName = toCamelCase(single.singularName) + 'Service';
  const actionsName = toCamelCase(single.singularName);
  const fileName = toKebabCase(single.singularName);

  return `/**
 * ${single.displayName} Actions (Single Type)
 * ${single.description || ''}
 * Generated by strapi2front
 */

import { defineAction, ActionError } from 'astro:actions';
import { z } from 'astro:schema';
import { ${serviceName} } from '${servicesImportPath}/${fileName}.service';

/**
 * ${single.displayName} actions
 */
export const ${actionsName} = {
  /**
   * Get ${single.displayName}
   */
  get: defineAction({
    input: z.object({
      populate: z.union([z.string(), z.array(z.string())]).optional(),
    }).optional(),
    handler: async (input) => {
      try {
        const result = await ${serviceName}.find({
          populate: input?.populate,
        });

        if (!result) {
          throw new ActionError({
            code: 'NOT_FOUND',
            message: '${single.displayName} not found',
          });
        }

        return result;
      } catch (error) {
        if (error instanceof ActionError) throw error;
        throw new ActionError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to fetch ${single.singularName}',
        });
      }
    },
  }),

  /**
   * Update ${single.displayName}
   */
  update: defineAction({
    input: z.object({
      data: z.record(z.unknown()),
    }),
    handler: async ({ data }) => {
      try {
        const result = await ${serviceName}.update(data);
        return result;
      } catch (error) {
        throw new ActionError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to update ${single.singularName}',
        });
      }
    },
  }),
};
`;
}

